// Nesrine Naaman & Nguyen Huong GiangÂ LE

#include "../main/src/header.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>

// Defining a threshold for when the assertion returns true. 
// Since the floating-point numbers between our declared matrix examples and the ones returned by the algorithms might not have the exact same number of digits. 
#define EPSILON 1e-6

// if the difference between the values we obtained from our algorithms and the values we know are the correct answer is less than the threshold, assert returns true, and the test passes
int compare_matrices(int m, int n, double **a, double b[m][n]) {
    // input: size of the resulting matrix, matrix resulting from our algorithm, matrix we know is the correct answer (referred to here as test matrix. Ex: A_test, L_test, etc)
    // the function compares each element of algorithm-produced matrix and the test matrix
    // output: assert returns true if both difference between elements of both matrices is less than the EPSILON threshold we specified above
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            assert(fabs(a[i][j] - b[i][j]) < EPSILON);
        }
    }
    return 0;
}

// testing LU decomposition
void test_LU(int n, double A_test[n][n], double L_test[n][n], double U_test[n][n]) {
    // input: size of matrix A that we are calculating the LU decomposition for and te matrix A (A_test) along with its correct LU matrices L_test and U_test
    // the function uses the LU function to get the L and U matrices and compares them (using the compare_matrices function above) with the L_test and U_test which are the correct answers.
    double **A;
    A = (double **)malloc(n * sizeof(double *));
    // Allocating memory for n columns in each row
    for (int i = 0; i < n; i++) {
        A[i] = (double *)malloc(n * sizeof(double));
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            A[i][j] = A_test[i][j]; // Assigning values from the predefined array
        }
    }
    double **L;
    double **U;
    L = (double **)malloc(n * sizeof(double *));
    U = (double **)malloc(n * sizeof(double *));
    // Allocating memory for n columns in each row
    for (int i = 0; i < n; i++) {
        L[i] = (double *)malloc(n * sizeof(double));
        U[i] = (double *)malloc(n * sizeof(double));
    }
    // Calling the function and asserting the results
    LU(n,L,U,A);

    compare_matrices(n,n,L, L_test);

    for(int i=0; i<n;i++){
        free(A[i]);
        free(L[i]);
        free(U[i]);
    }
    free(A);
    free(L);
    free(U);
}

// testing matrix multiplication: Naive and Strassen
void test_Mult(int m, int n, int p, double A_test[m][n], double B_test[n][p], double C_test[m][p]){
    // input: sizes of matrix A and B that we are multiplying and the matrices A and B (A_test, B_test) along with their correct product matrix C_test
    // the function uses the multiplyNaive and multiplyStrassen functions to get the matrix C and compares it with the C_test.
    double **A, **B, **C1, **C2;
    A = (double **)malloc(m * sizeof(double *));
    B = (double **)malloc(n * sizeof(double *));
    C1 = (double **)malloc(m * sizeof(double *));
    C2 = (double **)malloc(m * sizeof(double *));
    // Allocating memory for m columns in each row
    for (int i = 0; i < m; i++) {
        A[i] = (double *)malloc(n * sizeof(double));
        C1[i] = (double *)malloc(p * sizeof(double));
        C2[i] = (double *)malloc(p * sizeof(double));
    }
    for (int i = 0; i < n; i++) {
        B[i] = (double *)malloc(p * sizeof(double));
    }
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            A[i][j] = A_test[i][j]; // Assigning values from the predefined array
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < p; j++) {
            B[i][j] = B_test[i][j]; // Assigning values from the predefined array
        }
    }
    // Calling the multiplyNaive and multiplyStrassen functions and asserting their results 
    multiplyNaive(m,n,p,A, B, C1);
    multiplyStrassen(m,n,p,A,B,C2);
    compare_matrices(m,p,C1, C_test);
    compare_matrices(m,p,C2, C_test);

    for(int i=0; i<m;i++){
        free(A[i]);
        free(C1[i]);
        free(C2[i]);
    }
    for(int i=0; i<n;i++){
        free(B[i]);
    }
    free(A);
    free(B);
    free(C1);
    free(C2);
}

void test_Inverse(int n, double A_test[n][n], double invA_test[n][n]){
    // input: size of matrix A that we are inverting, the matrix A (A_test), and its correct inverse invA_test
    // the function uses the inverseMatrix_LU, inverseMatrix_Strassen_Naive, and the inverseMatrix_Strassen_Strassen to get invA and compares it with invA_test
    double **A, **invA1, **invA2, **invA3;
    A = (double **)malloc(n * sizeof(double *));
    invA1 = (double **)malloc(n * sizeof(double *));
    invA2 = (double **)malloc(n * sizeof(double *));
    invA3 = (double **)malloc(n * sizeof(double *));
    // Allocating memory for n columns in each row
    for (int i = 0; i < n; i++) {
        A[i] = (double *)malloc(n * sizeof(double));
        invA1[i] = (double *)malloc(n * sizeof(double));
        invA2[i] = (double *)malloc(n * sizeof(double));
        invA3[i] = (double *)malloc(n * sizeof(double));
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            A[i][j] = A_test[i][j]; // Assigning values from the predefined array
        }
    }
    
    // Calling all 3 inverse functions we have and asserting their results 
    inverseMatrix_LU(n,A,invA1);
    inverseMatrix_Strassen_Naive(n,A,invA2);
    inverseMatrix_Strassen_Strassen(n,A,invA3);


    compare_matrices(n,n,invA1, invA_test);
    compare_matrices(n,n,invA2, invA_test);
    compare_matrices(n,n,invA3, invA_test);

    for(int i=0; i<n;i++){
        free(A[i]);
        free(invA1[i]);
        free(invA2[i]);
        free(invA3[i]);
    }
    free(A);
    free(invA1);
    free(invA2);
    free(invA3);
}

// First test: LU
// with 5x5 matrix A_test and 10x10 matrix A_test2
void test1(){
    // size: 5x5
    double A_test[5][5] = {
        { 0.2993944219, -0.0779513870, -0.1289625341,  0.5266898151,  0.0757226306},
        { 0.6702531100,  0.9440191760,  0.1302917018, -0.1873674976,  0.9144684262},
        {-0.5291605618,  0.3984386322,  0.5580915220, -0.1557899365, -0.3614627483},
        { 0.8955891178,  0.1663035951, -0.9354764856, -0.5532936433,  0.7937368675},
        { 0.3355322505, -0.7094657671,  0.0088519868,  0.7753429579, -0.8109058457}
    };
    // expected answers
    double L_test[5][5] = {
        { 1.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000},
        { 2.2386960510,  1.0000000000,  0.0000000000,  0.0000000000,  0.0000000000},
        {-1.7674362749,  0.2330423326,  1.0000000000,  0.0000000000,  0.0000000000},
        { 2.9913353502,  0.3571498495, -3.0077866781,  1.0000000000,  0.0000000000},
        { 1.1207030792, -0.5561819217,  1.6619258166, -1.4513088650,  1.0000000000}
    };
    double U_test[5][5] = {
        {0.2993944219, -0.0779513871,-0.1289625341,  0.5266898151,  0.0757226306},
        {0.0000000000,  1.1185286385, 0.4189996176, -1.3664659068,  0.7449484720},
        {0.0000000000,  0.0000000000, 0.2325138129,  1.0935451507, -0.4012323537},
        {0.0000000000,  0.0000000000, 0.0000000000,  1.6483841234, -0.9056544773},
        {0.0000000000,  0.0000000000, 0.0000000000,  0.0000000000, -1.1290075228}
    };
    test_LU(5,A_test, L_test, U_test);

    // size: 10x10
    double A_test2[10][10] = {
        { 0.8053848472,  0.1031276449, -0.7336719808, -0.8249810700,  0.5431558022,  0.8195675937,  0.4725466750,  0.0919666724, -0.3161373489,  0.6795767926},
        {-0.3528466874, -0.2942744304,  0.1296483786, -0.9997001151,  0.0401661503, -0.9275113772, -0.6837170430,  0.7676584375,  0.0353589622,  0.2780769175},
        {-0.3612471034,  0.5199337637,  0.5267659666, -0.6443998989, -0.4291006855,  0.1047790186, -0.9790343288, -0.6299645359,  0.1860454041,  0.8651074580},
        {-0.1389530241,  0.6165236065, -0.0877451492, -0.7327225216, -0.8674211213, -0.7467852653,  0.7800465123,  0.2417317281,  0.7851537400,  0.0789079382},
        { 0.2057180867, -0.4961174622, -0.2461866817,  0.3404411372, -0.2058063211, -0.9868386378,  0.2030137382,  0.0518987035,  0.2615092021, -0.8148406948},
        { 0.9724424425, -0.1598682567, -0.9057908449,  0.3732699619, -0.4517511024, -0.5807786768,  0.8527786647,  0.6510179749, -0.3408958620,  0.5632471701},
        { 0.4951878020,  0.6213883011, -0.3268237986, -0.9275835091,  0.1039627060, -0.6988005152, -0.7402596929,  0.4553417114,  0.9281432768, -0.6959468302},
        {-0.7783748898, -0.1467722352, -0.8009575884,  0.3058119925, -0.2178416630,  0.7351693938, -0.0079980935, -0.4239574668,  0.5468553088,  0.9971756032},
        {-0.4696374822,  0.8028369992, -0.7185543560, -0.7430613654, -0.6323689509, -0.2249583375, -0.8747780686, -0.3949983909, -0.7379554723, -0.8176231151},
        { 0.2083051909,  0.9853431201,  0.6618187482, -0.8122992962, -0.3142707708,  0.0511553451, -0.2321153652,  0.8370569618,  0.4163564012, -0.2979642550},
    };
    // expected answers
    double L_test2[10][10] = {
        { 1.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000, 0.0000000000},
        {-0.4381094188,  1.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000, 0.0000000000},
        {-0.4485397318, -2.2730067457,  1.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000, 0.0000000000},
        {-0.1725299707, -2.5465011481,  2.9496109526,  1.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000, 0.0000000000},
        { 0.2554283053,  2.0974442595, -1.4417083710, -0.3236469013,  1.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000, 0.0000000000},
        { 1.2074257988,  1.1416899080, -0.8353894546, -0.0654088994,  1.5617072278,  1.0000000000,  0.0000000000,  0.0000000000,  0.0000000000, 0.0000000000},
        { 0.6148461865, -2.2400474086,  1.2816251949,  0.2309400473, -0.1912728015,-20.1694343974,  1.0000000000,  0.0000000000,  0.0000000000, 0.0000000000},
        {-0.9664632907,  0.1890984781,  6.1862144143,  3.2379666297, -2.6923067479, 31.1838479240, -1.0124343744,  1.0000000000,  0.0000000000, 0.0000000000},
        {-0.5831218253, -3.4644576758,  7.6009217100,  3.2516542156, -2.3920724890,  9.1077222139,  0.0155949416,  0.8796455829,  1.0000000000, 0.0000000000},
        { 0.2586405637, -3.8486397152, -0.4763537153, -1.0022802921,  0.7625199596,-18.3494099922,  0.6489595708, -0.5546178424, -0.4024099404, 1.0000000000},
    };
    double U_test2[10][10] = {
        {0.8053848472, 0.1031276449, -0.7336719808, -0.8249810700,  0.5431558022,  0.8195675937,  0.4725466750,  0.0919666724, -0.3161373489,  0.6795767926},
        {0.0000000000, 0.2490932378, -0.1917802265, -1.3611320922,  0.2781278232, -0.5684510951, -0.4766898938,  0.8079499029, -0.1031437880,  0.5758059112},
        {0.0000000000, 0.0000000000, -0.2382328154, -4.1082991141,  0.4467126906, -0.8197055264, -1.8505977143,  1.2477617501, -0.1902012836,  2.4787353706},
        {0.0000000000, 0.0000000000,  0.0000000000,  7.7767031466, -1.3830862904,  0.3648657402,  5.1062269012, -1.3653676337,  1.0289745869, -5.6488592816},
        {0.0000000000, 0.0000000000,  0.0000000000,  0.0000000000, -0.7315034601, -1.0675735662,  0.0667347215, -0.3092105173,  0.6174076295, -0.4507669157},
        {0.0000000000, 0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0849786135, -0.4897515711,  1.0535029053, -0.8972232578,  1.4905064918},
        {0.0000000000, 0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,-10.7713184494, 22.1142117836,-17.0807848884, 28.2802420915},
        {0.0000000000, 0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,-15.0813398161, 10.4536156352,-14.5595343936},
        {0.0000000000, 0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000, -2.4603628119, -1.1862130705},
        {0.0000000000, 0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000,  0.0000000000, -1.9500681777}
    };
    test_LU(10,A_test2, L_test2, U_test2);
}

// Second test: Matrix Multiplication
// with 2x3 A multiplied by 3x5 B and 7x9 matrix A2 multiplied by 9x7 matric B2
void test2(){
    // size: 2x3 . 3x5
    double A[2][3] = {
        {0.8312588240,  0.9670552462, -0.7024768040},
        {-0.5276449311, -0.1283573132, 0.6986375943}
    };
    double B[3][5] = {
        { 0.8312588240, 0.9670552462, -0.7024768040, -0.5276449311, -0.1283573132},
        { 0.6986375943, 0.0020478801,  0.4187206390, -0.5622196531,  0.7742907730},
        {-0.4949785059, 0.8962516263, -0.6989173739, -0.7043027113,  0.7843316075}
    };
    // expected answer
    double C[2][5] = {
        { 1.7143233022, 0.1762576419,  0.3119591918, -0.4875506523, 0.0911090440},
        {-0.8740953420, 0.1156304209, -0.1713774841, -0.1414781745, 0.5163047499}
    };
    test_Mult(2,3,5, A, B, C);

    // size: 7x9 . 9x7
    double A2[7][9] = {
        { 0.8355633271, -0.6871612750,  0.8804504033, -0.2700723732,  0.8936232635, -0.8738099252, -0.1234132019, -0.2056850834, -0.9491964429},
        { 0.8553835404,  0.4311641135,  0.5752562636,  0.3320229879,  0.3103580788,  0.1882308820, -0.4035658768, -0.7316920411,  0.4518644677},
        { 0.4861082730,  0.0217447891, -0.5353295941,  0.7155126257, -0.3792991775, -0.8812762284,  0.3904291156, -0.0578546091, -0.3624155677},
        { 0.8815540885,  0.2795654215,  0.6560396364,  0.0581693440, -0.3478353663, -0.0690015802,  0.2904423351, -0.5356741601,  0.9243906922},
        { 0.2343642866,  0.9605655568,  0.2253123593,  0.8248222563,  0.7876609619,  0.2177861795,  0.3323187089, -0.7194591648,  0.0498179286},
        {-0.7100739878, -0.2135132631, -0.5174135098, -0.1688589552, -0.0124605042,  0.5763059331, -0.0261823987, -0.0475745793,  0.4140461718},
        { 0.8740091025, -0.5290138747,  0.8638075599,  0.0136589245, -0.4344559235,  0.0992941936,  0.8375118504,  0.0616704342,  0.4949880072}
    };
    double B2[9][7] = {
        { 0.8355633271, -0.6871612750,  0.8804504033, -0.2700723732,  0.8936232635, -0.8738099252, -0.1234132019},
        {-0.2056850834, -0.9491964429,  0.8553835404,  0.4311641135,  0.5752562636,  0.3320229879,  0.3103580788},
        { 0.1882308820, -0.4035658768, -0.7316920411,  0.4518644677,  0.4861082730,  0.0217447891, -0.5353295941},
        { 0.7155126257, -0.3792991775, -0.8812762284,  0.3904291156, -0.0578546091, -0.3624155677,  0.8815540885},
        { 0.2795654215,  0.6560396364,  0.0581693440, -0.3478353663, -0.0690015802,  0.2904423351, -0.5356741601},
        { 0.9243906922,  0.2343642866,  0.9605655568,  0.2253123593,  0.8248222563,  0.7876609619,  0.2177861795},
        { 0.3323187089, -0.7194591648,  0.0498179286, -0.7100739878, -0.2135132631, -0.5174135098, -0.1688589552},
        {-0.0124605042,  0.5763059331, -0.0261823987, -0.0475745793,  0.4140461718,  0.8740091025, -0.5290138747},
        { 0.8638075599,  0.0136589245, -0.4344559235,  0.0992941936,  0.8375118504,  0.0616704342,  0.4949880072}
    };
    // expected answer
    double C2[7][7] = {
        {-0.6042955758,  0.1639534306, -0.6340736486, -0.7340874784, -0.8411711703, -1.4444255001, -2.0349859454},
        { 1.4979836904, -1.2325712475,  0.4100179427,  0.6451526554,  1.5683443047, -0.8765328506,  0.5666258927},
        {-0.2903775641, -1.1845923864, -0.4824419481, -0.4615439724, -0.9662849714, -1.7677405074,  0.6606354116},
        { 1.5848623506, -1.9073638378,  0.0243916338,  0.2180852662,  1.7216081154, -1.4011358694,  0.5412483728},
        { 1.2147896166, -1.5618540080,  0.4050071167,  0.3530086569,  0.6219755421, -0.5772650445,  0.8503540556},
        { 0.1111872238,  1.0874259004,  0.0924893324, -0.0038659074, -0.1902426482,  1.0473399994,  0.5162182721},
        { 1.6869231782, -1.2742340240, -0.4319019763, -0.4434692710,  1.2689811380, -1.3224170222, -0.3971097105}
    };    
    test_Mult(7,9,7, A2, B2, C2);
}

// Third test: Matrix Inversion
// with 5x5 matrix A and 2x2 matrix A2
void test3(){
    // size: 5x5
    double A[5][5] ={
        { 0.8577432576,  0.0909303227,  0.2659335040, -0.4555985022,  0.7559740896},
        {-0.3434758714, -0.7989708501, -0.3030774786,  0.1768176980, -0.2249493633},
        {-0.7239482802,  0.6012547042, -0.7121861296,  0.2877193137, -0.3014954018},
        { 0.7667820350, -0.6943375662,  0.2685241901, -0.9139374876, -0.5473540833},
        { 0.6199220194, -0.9706205446,  0.7805066788, -0.0242501698,  0.4273968169}
    };
    // expected answer
    double invA[5][5] = {
        { 2.2888431521, -9.9022121247, 35.0572917791,  7.3205030319, 24.8451009614},
        {-0.0264046011, -1.5308754478,  2.2718786113,  0.3963516349,  1.3511971887},
        {-1.9039760628,  3.0273613592,-15.7251618493,  -3.1460479951,-10.1608305324},
        { 1.2792928007, -9.1529503726, 32.1391687093,  5.9976215455, 23.2724514245},
        { 0.1697625739,  4.8382761255,-15.1491088637, -3.6324069504, -10.7524628946}
    };
    test_Inverse(5, A, invA);

    // size: 2x2
    double A2[2][2] ={
        {1.00000000, 0.0000000},
        {0.0000000, 1.0000000}
    };
    // expected answer
    double invA2[2][2] = {
        {1.0000000, 0.0000000},
        {0.0000000, 1.0000000}
    };
    test_Inverse(2, A2, invA2);
}

// Running the 3 tests
int main() {
    test1();
    test2();
    test3();
    return 0;
}